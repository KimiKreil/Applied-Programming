#ifndef SPARSE_VECTOR_HPP
#define SPARSE_VECTOR_HPP

#include "Vector.hpp"
#include "Matrix.hpp"
#include <iostream>
#include <algorithm>

template<class T> class SparseVector{
private:
	//We will keep track of the sparse vector, without saving all zeros through 3 members:

	// mDimension contains the dimension of the true vector, even though we don't store all of it
	int mDimension;

	// mIndices keeps track of the indices in the vector that are non-zero
	// Indices are sorted in increasing order. Indices are always integers!
	std::vector<int> mIndices;

	// mValues keeps track of the values that are in the entries specified by the indices
	// Values are sorted according to the order of the indices
	std::vector<T> mValues;

public:
	//creates an empty vector of dimensionality 0.
	SparseVector(){
		mDimension = 0;
	}

	// Creates a vector of dimensionality dim. It starts with 0 nonzero elements
	// which need to be set using setValue
	SparseVector(unsigned int dim){
		// Specify dimension, the rest is added later
		mDimension = dim;
	}

	// assignment operators and copy constructor should be automatically
	// generated by the compiler when using a std::vector for internal storing.
	// However, test that assignment works!

	//sets the value v_i of the vector. if it does not exist it is added
	void setValue(unsigned int index, T value){

		// Check that it is a valid index (since it is unsigned we dont have to check for negative)
		assert(index < mDimension);

		// Find the lower bound within the range of indices already existing (first, last, value)
		// .begin() and .end() returns a random acces iterator pointing to the first element in the vector
		auto lower_ind = std::lower_bound(mIndices.begin(), mIndices.end(), index);
		// The actual position (index) is the lower bound minus the starting position memory.
        auto position = lower_ind - mIndices.begin();

		// CASE 1: The index is larger than any other index
		/* 
		We check if the position (the index in our index list) is equal to the number of non-zero elements stored.
		This would mean that the lower bound, is at the end of the list, and thus this value(and its index) should 
		be stored in the end of the arrays. This also ensures that the index is not already non-zero, since that 
		would return the position one before. We can therefore just add it to the end of the arrays, since the index cannot already exist. 
		Push_back does exactly this, and is used for both members.
		*/
		if (position == nonZeroes() ){
			mIndices.push_back(index);
			mValues.push_back(value);
		}

		// CASE 2: The index goes somewhere within the list, and the index is already a non-zero element
		/*
		In this case, the members do not need to change dimension, 
		and we can just change the entry in the value array for the given value. 
		The index is already correct in this case, and is thus not changed.
		The position variable, is the index in the list of indices, and is what we
		use to access the right entry. We also use this to check if we are working with CASE 2.
		*/
		else if(mIndices[position] == index){
			mValues[position] = value;
		}

		// CASE 3: The index goes somewhere within the list, and the index is NOT already a non-zero element
		/*
		In this case we need to insert a new element in both mIndices and mValues. 
		We can use the insert method for this, which takes (iterator_pos, val), where
		iterator_pos is an iterator pointing to the element right before where we want the val to be inserted.
		For mIndices iterator_pos should thus be lower_ind. We will calculate a lower_val in a similar way, that
		tells us where to insert the value in the memory.
		*/
		else{
			auto lower_val = mValues.begin() + position;
			mValues.insert(lower_val, value);

			mIndices.insert(lower_ind, index);
		}
	}

	//returns the value v_i of the vector. Returns 0 if the value is not stored
	T getValue(unsigned int index) const{

		// Check that it is a valid index (since it is unsigned we dont have to check for negative)
		assert(index < mDimension);

		// Find the lower bound within the range of indices already existing (first, last, value)
		// .begin() and .end() returns a random acces iterator pointing to the first element in the vector
		auto lower_ind = std::lower_bound(mIndices.begin(), mIndices.end(), index);
		// The actual position (index) is the lower bound minus the starting position memory.
        auto position = lower_ind - mIndices.begin();

		// Check if index exist (if it matches the index at that position)
		if( mIndices[position] == index ){
			// It does, we can just return the value
			return mValues[position];
		}

		// If index does not exist already or something else went wrong
		else{
			// We return 0
			return 0;
		}
	}

	//returns the dimensionality of the vector
	unsigned int size() const{
		return mDimension;
	}

	// returns the number stored elements
	unsigned int nonZeroes() const{
		return mIndices.size();
	}

	//returns the index of the ith stored nonzero entry (in increasing order)
	unsigned int indexNonZero(unsigned int i) const{
		// Check that it is a valid index (since it is unsigned we dont have to check for negative)
		assert(i < nonZeroes() );

		// Return the index at the i'th spot
		return mIndices[i];
	}

	//returns the value of the ith stored nonzero entry (in increasing order)
	T valueNonZero(unsigned int i) const{
		// Check that it is a valid index (since it is unsigned we dont have to check for negative)
		assert(i < nonZeroes() );

		// Return the value at the i'th spot
		return mValues[i];
	}


	// Adds x to the current vector
	SparseVector<T>& operator+= (SparseVector<T> const& x){
		/*
		For each non-zero element in x we set the corresponding value in this to the current value plus the value in x:
		z_i = z_i + x_i
		*/

		// Get number of nonzero elements in x (the ones we need to add)
        int N_nonzero = x.nonZeroes();

		// Loop only over the non-zero elements, to decrease the computing time (also the point with sparsevectors)
        for (int i=0; i<N_nonzero; i++){

			// Get the index in the sparse vector x
            int index = x.indexNonZero(i);

			// Perform the addition (z_i+x_i) and save to a temporary variable
			T new_value = getValue(index) + x.valueNonZero(i);

			// Update the value in the sparse vector (z)
            setValue(index, new_value);
        }
        return *this;
    }

	// Subtract x from the current vector
	SparseVector<T>& operator-= (SparseVector<T> const& x){
		/*
		For each non-zero element in x we set the corresponding value in this to the current value minus the value in x:
		z_i = z_i - x_i
		*/

		// Get number of nonzero elements in x (the ones we need to add)
        int N_nonzero = x.nonZeroes();

		// Loop only over the non-zero elements, to decrease the computing time (also the point with sparsevectors)
        for (int i=0; i<N_nonzero; i++){

			// Get the index in the sparse vector x
            int index = x.indexNonZero(i);

			// Perform the subtraction (z_i-x_i) and save to a temporary variable
			T new_value = getValue(index) - x.valueNonZero(i);

			// Update the value in the sparse vector (z)
            setValue(index, new_value);
        }
        return *this;
    }

	// printer
    void print() const
    {
        std::cout << "size: " << size() << "\nNumber of non-zero elements: "
                  << nonZeroes() << "\n";
        if (nonZeroes() > 0)
        {
            std::cout << "index, values of non zeros:\n";
            for (unsigned int i = 0; i < nonZeroes(); i++)
            {
                std::cout << indexNonZero(i) << ", " << valueNonZero(i) 
                          << "\n";
            }
        }
    }

};

/* 
When creating template functions (ie, outside the main class definition,) we
need to add a template of type T. And also, of course, specify the type we
use in the functions. 
*/

// computes z= x+y, equivalent to z=x, z+=y
template<class T>
SparseVector<T> operator+(SparseVector<T> const& x, SparseVector<T> const& y){
    SparseVector<T> z(x);
    return z+=y;
}

// computes z= x-y, equivalent to z=x, z-=y
template<class T>
SparseVector<T> operator-(SparseVector<T> const& x, SparseVector<T> const& y){
    SparseVector<T> z(x);
    return z-=y;
}

// computes the matrix-vector product of a dense matrix and sparse vector z=Ax.
// The result is a dense vector.
/* 
We have already defined vector-matrix and matrix-vector multiplication in the vector.hpp file.
So if we create a dense vector object based on the sparsevector, we can just multiply them and return the result.
*/
template<class T>
Vector<T> operator* (Matrix<T> const& A, SparseVector<T> const& x){

	// Initialise the vector with the size mDimension that we can access with .size()
	// Since we are outside the class. This vector will be filled with zeros
	Vector<T> V(x.size());

	// Get number of nonzero elements in x (the ones we need to add)
    int N_nonzero = x.nonZeroes();

		// Loop only over the non-zero elements, to decrease the computing time (also the point with sparsevectors)
        for (int i=0; i<N_nonzero; i++){
		
			// Set the entries in V to the corresponding non-zero entries of x
			V[ x.indexNonZero(i) ] = x.valueNonZero(i);
		}

	// Return the result, from the definition of *operator in Matrix.hpp file
	return A*V;
}

// computes the matrix-vector product of a dense matrix and sparse vector z=x^TA.
// The result is a dense vector.
template<class T>
Vector<T> operator* (SparseVector<T> const& x, Matrix<T> const& A){

	// Initialise the vector with the size mDimension that we can access with .size()
	// Since we are outside the class. This vector will be filled with zeros
	Vector<T> V(x.size());

	// Get number of nonzero elements in x (the ones we need to add)
    int N_nonzero = x.nonZeroes();

		// Loop only over the non-zero elements, to decrease the computing time (also the point with sparsevectors)
        for (int i=0; i<N_nonzero; i++){
		
			// Set the entries in V to the corresponding non-zero entries of x
			V[ x.indexNonZero(i) ] = x.valueNonZero(i);
		}

	// Return the result, from the definition of *operator in Matrix.hpp file
	return V*A;
}

#endif

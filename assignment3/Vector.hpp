#ifndef VECTORHEADERDEF
#define VECTORHEADERDEF

#include <cassert>
#include <cmath>
#include <vector>
#include <iostream>

// MMAYBE I NEED TO ADD <T> AFTER EACH VECTOR INITIALISATION IN THE CODE??

// Adding a template parameter so that we can store arbitrary values of type T instead of only doubles
template<class T>

class Vector
{
private:
    // Replace the private member *mData and mSize, with an std::vector (this itself has a size member)
	std::vector<T> mData;

public:
    // Copy constructor (initialises with another vector)
    Vector(const Vector& otherVector){
        // Copy assignment copies data from otherVector to mData
        mData = otherVector.mData;
    }

    // Default constructor (initialises with a size)
    Vector(int size){
        // ALlocate space for that size vector and fill with zeros
        mData.resize(size);
    }

    int size() const { return mData.size(); }

    // Overload [] operator
    T& operator[](int index){
        // The .at method itself includes bounds checking and throws an out of range exception if it is not a valid index,
        // i.e. if index<0 or index>size
        return mData.at(index);
    }
    T const& operator[](int index) const{
        return mData.at(index);
    }

    // Assignment operator (bad coding practice, fx. if we add new members it would do it wrong now, and c++ can do it automatically)
    // Autogenerated by compiler
    /*
    Vector& operator=(const Vector& otherVector){
        mData = otherVector.mData;
        return *this;
    }
    */
   
    // Overload the unary - operator (defines -A)
	Vector operator-() const{

        // Get size of vector with built-in funciton
        int size = mData.size();

        // Define a new vector
        Vector otherVector(size);

        // Loop over elements
        for (int i=0; i<size; i++){
            // Invert sign of each element .at() is not used here, 
            // since we dont need to check if index is valid
            otherVector[i] = -mData[i];
        }
        return otherVector;
    }

    // Overload the binary - operator (defines A-B)
    Vector operator-(const Vector& otherVector) const{

        // Get size of vector with built-in funciton
        int size = mData.size();

        // Define a new vector
        Vector result(size);

        // Loop over elements
        for (int i=0; i<size; i++){
            // Perform subtraction of corresponding elements
            result[i] = mData[i] - otherVector.mData[i];
        }

        return result;
    }

    // Overload the binary + operator (defines A+B)
    Vector operator+(const Vector& otherVector) const{

        // Get size of vector with built-in funciton
        int size = mData.size();

        // Define a new vector
        Vector result(size);

        // Loop over elements
        for (int i=0; i<size; i++){
            // Perform addition of corresponding elements
            result[i] = mData[i] + otherVector.mData[i];
        }

        return result;
    }

    // Overload the operator * (scalar multiplication, defines vector*scalar IN THAT ORDER)
    Vector operator*(double scalar) const{

        // Get size of vector with built-in funciton
        int size = mData.size();

        // Define a new vector
        Vector result(size);

        // Loop over elements
        for (int i=0; i<size; i++){
            // Multiply each element with scalar
            result[i] = mData[i] * scalar;
        }

        return result;
    }
    
    // Define calculation of the p-norm: ||x||_p = (|x_1|^p + ... + |x_n|^p)^{1/p}
    // This will return a double independent of the type T
    double CalculateNorm(int p=2) const{

        // Initialise sum at zero
        double sum = 0.0;

        // Loop over elements
        for (int i=0; i<mData.size(); i++){

            // Add |x_n|^p to the sum
            sum += pow( std::abs(mData[i]), p);
        }

        return pow(sum, 1.0 / ((double)(p)));
    }

    // Get reference to internal vector
    std::vector<T> const& getStorage() const{
        return mData;
    }

    // EXTRA: add a Print method
    void print() const
    {
        std::cout << "Length: " << mData.size() << ", data:\n";
        for (int i = 0; i < mData.size() - 1; i++)
        {
            std::cout << mData[i] << ", ";
        }
        std::cout << mData[mData.size() - 1] << "\n";
    }
    
    // Overloading the insertion << operator (how it is printed)
    friend std::ostream& operator<<(std::ostream& output, const Vector& V){
        
        // Begin with a bracket
        output << "[ ";

        // Loop over elements in vector
        for (int i=0; i<V.mData.size(); i++){
            
            // Add element to output
            output << V.mData[i];

            if (i<V.mData.size()-1){
                output << ", ";
            }
        }

        // Close bracket
        output << " ]";

        return output;
    }
    

    /* ____ UNNECESSARY FUNCTIONS/METHODS ____
	
    ~Vector()
    {
        delete[] mData;
    }

	int size() const
    {
        return mSize;
    }

    // Assignment operator
	Vector& operator=(const Vector& otherVector)
    {
        assert(mSize == otherVector.mSize);

        for (int i = 0; i < mSize; i++)
        {
            mData[i] = otherVector.mData[i];
        }
        return *this;
    }
    ___________________________________________*/


};


#endif
